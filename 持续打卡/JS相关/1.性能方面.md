### 1. JS的加载和执行会阻塞页面渲染吗
答：js的加载和执行是否会阻塞页面，取决于js的加载方式和位置可以分为以下情况： <br />
**1.同步加载**<br />
 - 当浏览器遇到script标签时，如果没有设置defer和async属性，脚本将会同步加载和执行，此时js的加载和执行会阻塞页面的渲染。浏览器会在js加载并执行完毕后才继续解析和渲染后续的内容。<br />

**2.异步加载**
 - 当浏览器遇到script标签，并设置了async和defer属性时，js将会异步加载，不会阻塞页面的渲染。defer属性表示js会延迟执行，js和页面文档同时加载，但是要等页面解析完毕后，js才会执行，多个带defer属性的js会按照顺序执行， 而async表示js会在加载完就立即执行，等到js执行完毕后才会继续渲染页面，当遇到多个带有async属性的js时，他们会并行执行，没有先后顺序。注意，不管是defer还是async属性，js的加载都是并行进行的，也都不会阻塞DOM的加载和渲染，但是js的执行一定会阻塞页面的渲染，这是因为js的执行与DOM的渲染都依赖于浏览器的主线程，他们共享同一个线程资源，自然出现争夺资源，导致阻塞

### 2. 说一说防抖和节流

#### 1. 防抖（Debouncing）
防抖的概念是在一段连续操作结束后才执行一次函数。它的主要思想是设置一个定时器，在一段连续的操作后执行函数，如果在设定的时间内再次触发了这个操作，则清除之前的定时器并重新设立。这样可以确保只有在操作停止一段时间后才执行函数。<br />
**实现原理**<br />
1. 每次触发事件时都取消之前的延时调用方法。
2. 设立一个新的延时调用方法。

**适用场景：** <br />
- 输入框的搜索功能，避免用户输入过程中频繁发送请求。
- 窗口大小改变的监听事件，避免频繁触发重新渲染操作。
#### 2. 节流（Throttling）：
节流的概念是在一段时间内只执行一次函数。它的主要思想是设置一个定时器，在一段时间内只允许函数执行一次，之后将定时器重新设置，以便下次函数执行。这样可以确保函数在指定的时间间隔内最多执行一次。<br />
**实现原理**<br />
1. 设置一个标志位来表示是否可以执行函数。
2. 在指定时间间隔内，如果标志位为真，则执行函数并将标志位设置为假；否则忽略函数调用。
3. 在时间间隔结束后，重新将标志位设置为真。
**适用场景**<br />
- 滚动事件的监听，避免频繁触发滚动事件造成性能问题。
- 鼠标移动事件的监听，避免频繁执行操作。
#### 防抖和节流的区别：
- **执行时机不同**：防抖是在连续操作停止后执行，而节流是在一段时间内最多执行一次。
- **调用频率不同**：防抖会等待一段连续操作停止后执行函数，而节流会在一段时间间隔内最多执行一次函数。
综上所述，防抖和节流都是用于控制函数执行频率的工具，能够有效地优化性能和避免不必要的函数调用。在实际开发中，根据具体场景选择合适的方式来处理频繁触发的事件是非常重要的。

### JS的事件循环机制
JavaScript的事件循环机制是一种用于管理代码执行顺序的机制，它确保了 JavaScript 是单线程执行的同时，能够处理异步操作。事件循环机制的核心是由浏览器（对于前端 JavaScript）或 Node.js（对于后端 JavaScript）提供的运行时环境。<br />
事件循环机制包含以下几个主要的组成部分：
1. **调用栈（Call Stack）**：
   - JavaScript代码执行时，形成一个由函数调用所形成的栈结构，称为调用栈。每个函数调用都会在调用栈中创建一个帧，并在执行完成后从调用栈中弹出。

2. **消息队列（Message Queue）**：
   - 当异步事件完成时，比如定时器到期、HTTP 请求返回、用户交互事件等，会生成一个事件，被添加到消息队列中。
   - 消息队列中的事件按照加入的顺序排列。

3. **事件循环（Event Loop）**：
   - 事件循环负责监听调用栈和消息队列，它持续地检查两者的状态。
   - 如果调用栈为空，并且消息队列中有待处理的事件，事件循环就会将事件移出队列并推入调用栈，开始执行事件对应的回调函数。
   - 如果调用栈不为空，事件循环会继续等待，直到调用栈为空。

4. **微任务队列（Microtask Queue）**：
   - 微任务队列中的任务比消息队列中的任务优先级更高。
   - 在每一轮事件循环中，当调用栈为空时，事件循环会优先处理微任务队列中的任务，直到微任务队列为空，然后再处理消息队列中的任务。

综上所述，JavaScript 的事件循环机制通过调用栈、消息队列和事件循环等组件，确保代码的执行顺序和异步操作的处理顺序。这样的设计保证了 JavaScript 单线程执行的同时，能够有效地处理异步操作，使得 JavaScript 能够处理各种场景下的复杂逻辑和交互。 

### JS的宏任务和微任务
JavaScript 中微任务（Microtask）和宏任务（Macrotask）的执行顺序是由事件循环（Event Loop）来管理的。在一次事件循环中，宏任务执行完成后，会先执行所有微任务，然后再执行下一个宏任务。
具体来说，事件循环中的执行顺序如下：
1. 执行一个宏任务（例如：整体代码、setTimeout、setInterval、I/O、UI 渲染等）。
2. 执行过程中，如果产生了微任务（例如：Promise 的 then/catch/finally），则将微任务添加到微任务队列。
3. 宏任务执行完毕后，检查微任务队列，依次执行所有微任务，直到微任务队列为空。
4. 检查是否需要进行 UI 重渲染，如果需要则进行渲染。
5. 重复以上步骤，执行下一个宏任务。

这里需要注意的是，微任务比宏任务优先级更高，因此在一次事件循环中，微任务总是在下一个宏任务之前执行。这保证了微任务能够尽可能快地执行，从而在当前事件循环中处理完异步操作，避免了一些问题，比如优先级反转和防止 UI 渲染阻塞等。
因此，总体来说，JavaScript 中微任务和宏任务的执行顺序可以归纳为：
1. 当前宏任务执行完毕后，立即执行所有微任务。
2. 微任务执行完毕后，检查是否需要进行 UI 渲染。
3. 执行下一个宏任务。