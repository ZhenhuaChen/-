### 1. React类组件和函数式组件
**类组件**
 - 类组件是使用 ES6 的类语法创建的 React 组件。它们是以 JavaScript 类的形式定义的，并且扩展了 React.Component 类。
 - 类组件使用 render() 方法来返回 React 元素。 
 - 类组件可以包含状态（state）和生命周期方法（lifecycle methods），通过状态管理数据并响应数据的变化。
```jsx
import React, { Component } from 'react';

class MyClassComponent extends Component {
  render() {
    return <div>Hello, I'm a class component!</div>;
  }
}
```
**函数式组件**
 - 函数式组件是一种使用 JavaScript 函数定义的 React 组件。它们只是一个函数，接收 props 作为参数，并返回 React 元素。
 - 函数式组件不支持状态（state）和生命周期方法，但是可以使用 React Hooks 来实现组件级别的状态和生命周期等功能。
 - 函数式组件通常更简洁、易于理解和测试，并且性能上也比类组件稍微好一些。
```jsx
import React from 'react';

const MyFunctionalComponent = () => {
  return <div>Hello, I'm a functional component!</div>;
};
```
随着 React Hooks 的引入，函数式组件在许多场景下变得更加强大和灵活，因此在新的 React 项目中，通常更倾向于使用函数式组件。但对于一些复杂的组件，仍然可能会使用类组件。

### 2. 为什么if里面不能用hooks
在React中,hoos应该在函数组件的顶层进行调用,因为React依赖于Hooks的调用顺序来正确地管理组件的状态和生命周期，如果在条件语句中使用Hook，由于条件可能发生改变，这样一来，不能保证hooks的调用顺序始终保持一致，导致状态错乱<br />
### 3. 为什么hooks要保证状态序列
我们使用useState声明状态的时候，只给状态定义了初始值，并没有给状态加key；我们知道在之前的类组件中定义state状态总是以键值对的形式定义，而函数式组件的写法是种有序链表的形式，并没有自己的key。useState方法仅仅接受了状态初始值作为参数，所以不能以键值对的形式存储，只能以线性表的形式存储，因此线性表要保证顺序才能使得每次渲染的序列正确对应。
### 4. 了解React的Fiber吗
React Fiber 是 React 16 中引入的一种重新实现的调度算法，用于实现更加高效的渲染和更新机制。在 React 16 之前，React 使用的是基于递归的调度算法. 这种算法存在一个问题，就是在进行大量计算或者递归操作时，可能会阻塞浏览器的主线程，导致页面卡顿或者动画不流畅。<br />
React Fiber 的目标是解决这个问题，使得 React 应用能够更好地与浏览器进行协调，实现更加平滑的用户交互体验。Fiber 的核心思想是将渲染和更新过程分成小的、可中断的任务单元，通过优先级调度算法来控制任务的执行顺序，从而实现更灵活的调度和更高的性能。<br />
**React Fiber 的特点和原理包括以下几点：**
1. 任务分片：React Fiber 将任务分成小的片段，称为 Fiber 节点，每个 Fiber 节点表示一个可中断的任务单元。这样可以在执行任务时进行任务间的切换，实现任务的优先级调度。
2. 优先级调度：Fiber 使用了优先级调度算法，根据任务的优先级来确定执行顺序，从而保证高优先级任务优先执行，提高用户交互的响应速度。
3. 异步渲染：Fiber 支持异步渲染，可以在多个渲染周期之间分割工作，使得浏览器主线程可以及时响应用户交互事件，提高页面的响应速度。
4. 增量更新：Fiber 使用增量更新的方式来更新 UI，只更新发生变化的部分，减少了不必要的 DOM 操作，提高了渲染性能。
5. 中断与恢复：Fiber 允许在任务执行过程中中断任务，并在稍后恢复执行，这样可以更好地控制任务的执行顺序，提高了渲染的灵活性和性能
### 5. 说一下React的虚拟DOM
React 中的虚拟 DOM 是一种用 JavaScript 对象表示的轻量级 DOM 结构的抽象。它是 React 实现高效更新 DOM 的核心机制之一。虚拟 DOM 是一个由 React 组件树的 JavaScript 对象表示的内存中的副本。它是对真实 DOM 结构的抽象描述，并不直接操作浏览器中的 DOM，而是通过与真实 DOM 进行比较和更新来实现页面的渲染。虚拟 DOM 对象通常包含了以下属性：<br />
**type** 表示元素类型，如 div、span、或自定义组件。<br />
**props** 包含了元素的属性，如 className、style 等。 <br />
**children** 子节点，可以是文本节点、元素节点或其他组件。 <br />
**key** 用于优化列表渲染的唯一标识。 <br />
接下来说一下虚拟DOM的工作原理： 当组件首次渲染时，React 会根据组件的状态和属性构建虚拟 DOM 树。当组件的状态发生变化时，React 会生成一个新的虚拟 DOM 树，并通过 diff 算法比较新旧虚拟 DOM 树的差异。React 将差异应用到真实 DOM 上，实现页面的更新。<br />
与真实 DOM 的比较：通过 diff 算法，React 能够高效地找出虚拟 DOM 树中发生变化的部分，并最小化对真实 DOM 的操作，以提高页面的性能

### 5 说一下react的diff 算法
React 中的 Virtual DOM 通过 diff 算法实现高效的 DOM 更新。<br />
下面是 React diff 的基本原理：
1. **虚拟 DOM 构建**：在 React 中，组件渲染时会先构建一个虚拟 DOM 树，这是一个轻量级的 JavaScript 对象树，它描述了真实 DOM 结构。每当状态发生变化时，React 会重新构建这个虚拟 DOM 树。
2. **Diff 算法**：当新的虚拟 DOM 树生成后，React 会将新旧虚拟 DOM 树进行比较，找出变化的部分。这个过程就是 Diff 算法的核心。
3. **比较节点**：React 使用深度优先搜索算法比较两棵虚拟 DOM 树的对应节点。在比较节点时，React 会做以下几种简单的假设：
   - 同一层级的节点，拥有相同的类型，React 会假设它们是相同的节点，不会再深入比较它们的子节点。
   - 当节点的类型不同时，React 会销毁旧节点，并创建新节点。
   - 当节点的类型相同时，React 会更新相同节点的属性，以确保与新的状态保持一致。
4. **递归更新**：在比较过程中，如果节点类型相同，React 会递归地比较其子节点。这样就能够找到具体哪些节点需要更新、删除或者新增。
5. **键值优化**：React 通过节点的唯一标识（通常是 key 属性）来优化 diff 过程。当列表发生变化时，React 会尽量复用相同 key 的节点，而不是销毁并重新创建节点，以提高性能。
6. **批处理更新**：React 会将所有的 DOM 变更操作缓存起来，在一次更新周期内批量执行这些操作，减少了频繁的 DOM 操作，提高性能。
通过这样的方式，React 能够高效地更新 DOM，避免不必要的操作，从而提升了应用的性能和用户体验。


